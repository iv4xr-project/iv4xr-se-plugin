package spaceEngineers.util.generator.python

import spaceEngineers.controller.SpaceEngineers
import java.io.File
import kotlin.reflect.KClass
import kotlin.reflect.KFunction
import kotlin.reflect.KProperty1
import kotlin.reflect.KType
import kotlin.reflect.full.createType
import kotlin.reflect.full.memberProperties

fun main() {
    val text = DataStructuresGenerator().generate()

    val modelsFile = File("../PythonClient/spaceengineers/models.py")
    modelsFile.writeText(
        """# Generated by JVMClient, see DataStructuresGenerator.kt
# pylint: disable=C0103,C0115,C0114,R0902
            
from dataclasses import dataclass
from typing import List, Dict, TypeVar, Generic

        """.trimIndent()
    )
    modelsFile.appendText(text)
}

fun generateDataClass(ktype: KType, validNestedTypes: Set<KType>): String {
    if (ktype.classifier !is KClass<*>) {
        // TODO: fix this, probably because of typealias usage
        return ""
    }
    val klass = ktype.classifier as KClass<*>
    return generateDataClass(klass, validNestedTypes)
}

fun generateDataClass(klass: KClass<*>, validNestedTypes: Set<KType>): String {
    if (klass.qualifiedName?.startsWith("spaceEngineers") != true) {
        return ""
    }
    val classHeader = """${defineGenerics(klass)}@dataclass
class ${klass.simpleName}${generateGenerics(kclass = klass)}:
"""
    val next = klass.memberProperties.filter { it.name != "dimensions" }
        .joinToString("\n") {
            // println(it)
            """$TAB${it.name.firstUppercase()}: '${it.returnType.toPythonType(validNestedTypes, klass.typeParameters)}'"""
        }
    val classBody = next.ifBlank {
        "${TAB}pass"
    }
    return classHeader + classBody
}

fun defineGenerics(klass: KClass<*>): String {
    if (klass.typeParameters.isEmpty()) {
        return ""
    }
    return klass.typeParameters.joinToString("") { "${it.name} = TypeVar('${it.name}')\n" }
}

fun generateGenerics(kclass: KClass<*>): String {
    if (kclass.typeParameters.isEmpty()) {
        return ""
    }
    return kclass.typeParameters.joinToString(", ", prefix = "(Generic[", postfix = "])") { it.name }
}

fun KType.toKClass(): KClass<*>? {
    if (classifier is KClass<*>) {
        return classifier as KClass<*>
    }
    return null
}

fun KType.containsMemberOfType(type: KType): Boolean {
    if (this.toString().contains("kotlin") && type.toString().contains("kotlin")) {
        return false
    }
    return (
        toKClass()?.run {
            memberProperties.map { it.returnType }.any { property ->
                (property == type) ||
                    property.arguments.mapNotNull { argumentProjection -> argumentProjection.type }
                        .contains(type)
            }
        } == true
        )
}

class DataStructuresGenerator(
    private val finishedTypes: MutableSet<KType> = mutableSetOf<KType>(
        Int::class.createType(),
        Float::class.createType(),
        String::class.createType(),
        Boolean::class.createType(),
        Unit::class.createType(),
        String::class.createType(nullable = true),
        Long::class.createType(),
        Byte::class.createType(),
        Short::class.createType(),
        Double::class.createType(),
    )
) {

    fun generate(): String {
        val types = find().toSet().sortedWith { x, y ->
            if (x.containsMemberOfType(y)) {
                x.arguments.count { it.type != null } + 100
            } else if (y.containsMemberOfType(x)) {
                -y.arguments.count { it.type != null } - 100
            } else {
                y.arguments.count { it.type != null } - x.arguments.count { it.type != null }
            }
        }.filter { it.toString().length > 4 }

        return types.map { generateDataClass(it, types.toSet()) }.distinct().sorted().joinToString("\n")
    }

    fun find(): List<KType> {
        return exploreInterfaces(SpaceEngineers::class)
            .includeGenerics().filter { it !in finishedTypes }
    }

    fun List<KType>.includeGenerics(): List<KType> {
        return flatMap {
            listOf(it) + it.arguments.mapNotNull { it.type }
        }
    }

    val exploredInterfaces = mutableListOf<KClass<*>>()

    fun List<KType>.includeDataMembers(): List<KType> {
        return flatMap { listOf(it) + properties(it) }
    }

    fun properties(type: KType): List<KType> {
        return type.toKClass()?.let {
            it.memberProperties.filter { it.name !in setOf("dimensions", "statsWrapper") }.map {
                it.returnType
            }
        } ?: emptyList<KType>()
    }

    fun exploreInterfaces(kclass: KClass<*>): List<KType> {
        if (kclass in exploredInterfaces) {
            return emptyList()
        }
        exploredInterfaces.add(kclass)

        val subInterfaces = kclass.members.filterIsInstance<KProperty1<*, *>>().map { it.returnType }

        val functionalParameterTypes = findFunctionTypes(kclass)

        val nestedTypes = subInterfaces.mapNotNull { it.toKClass() }.flatMap {
            exploreInterfaces(it)
        }

        return (functionalParameterTypes + nestedTypes).includeGenerics().includeDataMembers()
    }

    fun findFunctionTypes(kclass: KClass<*>): List<KType> {
        return kclass.members.filterIsInstance<KFunction<*>>().filter { it.name !in filteredMethods }.flatMap {
            functionKTypes(it)
        }
    }

    fun <T> List<T>.skipFirst(): List<T> {
        if (isEmpty()) {
            return emptyList()
        }
        return subList(1, size)
    }

    private fun functionKTypes(kFunction: KFunction<*>): List<KType> {
        return (kFunction.parameters.skipFirst().map { it.type } + listOf(kFunction.returnType)).filter {
            !it.isMarkedNullable
        }
    }
}
