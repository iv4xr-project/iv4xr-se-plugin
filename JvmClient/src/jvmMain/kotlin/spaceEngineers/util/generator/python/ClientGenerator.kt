package spaceEngineers.util.generator.python

import spaceEngineers.controller.SpaceEngineers
import java.io.File
import kotlin.reflect.*

fun main() {
    val types = DataStructuresGenerator().find().toSet()
    val clientGenerator = ClientGenerator(SpaceEngineers::class, types)

    val outFile = File("../PythonClient/spaceengineers/api.py")
    outFile.writeText(
        """# Generated by JVMClient, see ClientGenerator.kt
# pylint: disable=C0115,C0116,R0902,C0103,R0903,R0913,W0401,W0622,C0114,R0205,W0614
            
from typing import List, Dict
from .models import *

        """.trimIndent()
    )
    outFile.appendText(clientGenerator.generateInterfaces())
}

val filteredMethods = setOf("toString", "equals", "hashCode")

val kotlinTypeToPython = mapOf(
    "String" to "str",
    "Int" to "int",
    "Float" to "float",
    "Double" to "float",
    "Map" to "Dict",
    "Boolean" to "bool",
    "List" to "List",
    "Short" to "int",
    "Collection" to "List",
    "Byte" to "int",
    "Long" to "int",
    "Set" to "set",
    "Char" to "str",
)

val kotlinMethodToPython = mapOf(
    "continue" to "Continue"
)

fun KType.toPythonType(validTypes: Set<KType>, typeParameters: List<KTypeParameter> = emptyList()): String {
    val kclass = toKClass() ?: return this.toString()
    if (kclass.isValue) {
        return "object"
    }
    if (arguments.isNotEmpty()) {
        return kclass.simpleName?.let { kotlinTypeToPython[it] ?: it }!! + arguments.joinToString(
            prefix = "[",
            postfix = "]",
            separator = ", "
        ) {
            it.type!!.toPythonType(validTypes, typeParameters)
        }
    }
    if (kclass.simpleName in kotlinTypeToPython || kclass.simpleName in validTypes.mapNotNull { it.toKClass()?.simpleName }) {
        return kclass.simpleName?.let { kotlinTypeToPython[it] ?: it } ?: error("No simple name for $this")
    }
    return "object"
}

fun KType.toPythonTypeOrKeep(validTypes: Set<KType>): String {
    val kclass = toKClass()!!
    if (kclass.isValue) {
        return "object"
    }
    if (kclass == List::class) {
        return "List[${this.arguments.first().type!!.toPythonType(validTypes)}]"
    }
    return kclass.simpleName?.let { kotlinTypeToPython[it] ?: it } ?: error("No simple name for $this")
}

fun String.firstUppercase(): String {
    return this.substring(0, 1).uppercase() + this.substring(1, length)
}

fun String.toPythonMethod(): String {
    return kotlinMethodToPython[this] ?: firstUppercase()
}

const val TAB = "    "

class ClientGenerator(val iface: KClass<*>, val types: Set<KType>) {

    fun generateInterfaces(): String {
        return generateInterface(iface).distinct().joinToString("\n")
    }

    fun generateInterface(kclass: KClass<*>): List<String> {
        var result = ""
        result += """
class ${kclass.simpleName}:
"""
        val properties = kclass.members.filterIsInstance<KProperty1<*, *>>().map {
            """${it.name.firstUppercase()}: ${(it.returnType).toPythonTypeOrKeep(validTypes = types)}"""
        }

        val functions = kclass.members.filterIsInstance<KFunction<*>>().filter { it.name !in filteredMethods }.map {
            """def ${it.name.toPythonMethod()}(self${printParameters(it)})${returnType(it)}:"""
        }
        result += properties.joinToString(separator = "\n", postfix = "\n") {
            "$TAB$it"
        }
        result += functions.joinToString(separator = "\n\n", postfix = "\n") {
            "$TAB$it\n$TAB${TAB}pass"
        }
        if (properties.isEmpty() && functions.isEmpty()) {
            result += "${TAB}pass\n"
        }

        val referenced: List<String> = kclass.members.filterIsInstance<KProperty1<*, *>>().flatMap {
            generateInterface(it.returnType.classifier as KClass<*>)
        }

        return referenced + listOf(result)
    }

    private fun returnType(it: KFunction<*>): String {
        if (it.returnType.classifier == Unit::class) {
            return " -> None"
        }
        return " -> ${(it.returnType).toPythonType(types)}"
    }

    fun printParameters(func: KFunction<*>): String {
        if (func.parameters.isEmpty()) {
            return ""
        }
        val parameters = func.parameters.subList(1, func.parameters.size)
        if (parameters.isEmpty()) {
            return ""
        }
        return parameters.joinToString(prefix = ", ", separator = ", ") {
            "${it.name}: ${it.type.toPythonType(types)}"
        }
    }
}
